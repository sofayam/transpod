"""
This type stub file was generated by pyright.
"""

import mlx.core as mx
from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Sequence, Tuple, Union
from .tokenizer import Tokenizer

def compression_ratio(text) -> float:
    ...

def detect_language(model: Whisper, mel: mx.array, tokenizer: Tokenizer = ...) -> Tuple[mx.array, List[dict]]:
    """
    Detect the spoken language in the audio, and return them as list of strings, along with the ids
    of the most probable language tokens and the probability distribution over all language tokens.
    This is performed outside the main decode loop in order to not interfere with kv-caching.

    Returns
    -------
    language_tokens : mx.array, shape = (n_audio,)
        ids of the most probable language tokens, which appears after the startoftranscript token.
    language_probs : List[Dict[str, float]], length = n_audio
        list of dictionaries containing the probability distribution over all languages.
    """
    ...

@dataclass(frozen=True)
class DecodingOptions:
    task: str = ...
    language: Optional[str] = ...
    temperature: float = ...
    sample_len: Optional[int] = ...
    best_of: Optional[int] = ...
    beam_size: Optional[int] = ...
    patience: Optional[float] = ...
    length_penalty: Optional[float] = ...
    prompt: Optional[Union[str, List[int]]] = ...
    prefix: Optional[Union[str, List[int]]] = ...
    suppress_tokens: Optional[Union[str, Iterable[int]]] = ...
    suppress_blank: bool = ...
    without_timestamps: bool = ...
    max_initial_timestamp: Optional[float] = ...
    fp16: bool = ...


@dataclass(frozen=True)
class DecodingResult:
    audio_features: mx.array
    language: str
    language_probs: Optional[Dict[str, float]] = ...
    tokens: List[int] = ...
    text: str = ...
    avg_logprob: float = ...
    no_speech_prob: float = ...
    temperature: float = ...
    compression_ratio: float = ...


class Inference:
    def __init__(self, model: Whisper) -> None:
        ...
    
    def logits(self, tokens: mx.array, audio_features: mx.array) -> mx.array:
        """Perform a forward pass on the decoder and return per-token logits"""
        ...
    
    def rearrange_kv_cache(self, source_indices): # -> None:
        """Update the key-value cache according to the updated beams"""
        ...
    
    def reset(self): # -> None:
        ...
    


class SequenceRanker:
    def rank(self, tokens: List[List[mx.array]], sum_logprobs: List[List[float]]) -> List[int]:
        """
        Given a list of groups of samples and their cumulative log probabilities,
        return the indices of the samples in each group to select as the final result
        """
        ...
    


class MaximumLikelihoodRanker(SequenceRanker):
    """
    Select the sample with the highest log probabilities, penalized using either
    a simple length normalization or Google NMT paper's length penalty
    """
    def __init__(self, length_penalty: Optional[float]) -> None:
        ...
    
    def rank(self, tokens: List[List[List[int]]], sum_logprobs: List[List[float]]): # -> list[intp]:
        ...
    


class TokenDecoder:
    def reset(self): # -> None:
        """Initialize any stateful variables for decoding a new sequence"""
        ...
    
    def update(self, tokens: mx.array, logits: mx.array, sum_logprobs: mx.array) -> Tuple[mx.array, bool, mx.array]:
        """Specify how to select the next token, based on the current trace and logits

        Parameters
        ----------
        tokens : mx.array, shape = (n_batch, current_sequence_length)
            all tokens in the context so far, including the prefix and sot_sequence tokens

        logits : mx.array, shape = (n_batch, vocab_size)
            per-token logits of the probability distribution at the current step

        sum_logprobs : mx.array, shape = (n_batch)
            cumulative log probabilities for each sequence

        Returns
        -------
        tokens : mx.array, shape = (n_batch, current_sequence_length + 1)
            the tokens, appended with the selected next token

        completed : bool
            True if all sequences has reached the end of text

        sum_logprobs: mx.array, shape = (n_batch)
            updated cumulative log probabilities for each sequence

        """
        ...
    
    def finalize(self, tokens: mx.array, sum_logprobs: mx.array) -> Tuple[Sequence[Sequence[mx.array]], List[List[float]]]:
        """Finalize search and return the final candidate sequences

        Parameters
        ----------
        tokens : mx.array, shape = (n_audio, n_group, current_sequence_length)
            all tokens in the context so far, including the prefix and sot_sequence

        sum_logprobs : mx.array, shape = (n_audio, n_group)
            cumulative log probabilities for each sequence

        Returns
        -------
        tokens : Sequence[Sequence[mx.array]], length = n_audio
            sequence of mx.arrays containing candidate token sequences, for each audio input

        sum_logprobs : List[List[float]], length = n_audio
            sequence of cumulative log probabilities corresponding to the above

        """
        ...
    


@mx.compile
def categorical(logits, temp): # -> array:
    ...

class GreedyDecoder(TokenDecoder):
    def __init__(self, temperature: float, eot: int) -> None:
        ...
    
    def update(self, tokens: mx.array, logits: mx.array, sum_logprobs: mx.array) -> Tuple[mx.array, bool, mx.array]:
        ...
    
    def finalize(self, tokens: mx.array, sum_logprobs: mx.array): # -> tuple[array, array]:
        ...
    


class LogitFilter:
    def apply(self, logits: mx.array, tokens: mx.array) -> mx.array:
        """Apply any filtering or masking to logits

        Parameters
        ----------
        logits : mx.array, shape = (n_batch, vocab_size)
            per-token logits of the probability distribution at the current step

        tokens : mx.array, shape = (n_batch, current_sequence_length)
            all tokens in the context so far, including the prefix and sot_sequence tokens

        """
        ...
    


class SuppressBlank(LogitFilter):
    def __init__(self, tokenizer: Tokenizer, sample_begin: int, n_vocab: int) -> None:
        ...
    
    def apply(self, logits: mx.array, tokens: mx.array) -> mx.array:
        ...
    


class SuppressTokens(LogitFilter):
    def __init__(self, suppress_tokens: Sequence[int], n_vocab: int) -> None:
        ...
    
    def apply(self, logits: mx.array, tokens: mx.array) -> mx.array:
        ...
    


class ApplyTimestampRules(LogitFilter):
    def __init__(self, tokenizer: Tokenizer, sample_begin: int, max_initial_timestamp_index: Optional[int]) -> None:
        ...
    
    def apply(self, logits: mx.array, tokens: mx.array) -> mx.array:
        ...
    


class DecodingTask:
    inference: Inference
    sequence_ranker: SequenceRanker
    decoder: TokenDecoder
    logit_filters: List[LogitFilter]
    def __init__(self, model: Whisper, options: DecodingOptions) -> None:
        ...
    
    def run(self, mel: mx.array) -> List[DecodingResult]:
        ...
    


def decode(model: Whisper, mel: mx.array, options: DecodingOptions = ..., **kwargs) -> Union[DecodingResult, List[DecodingResult]]:
    """
    Performs decoding of 30-second audio segment(s), provided as Mel spectrogram(s).

    Parameters
    ----------
    model: Whisper
        the Whisper model instance

    mel: mx.array, shape = (80, 3000) or (*, 80, 3000)
        An array containing the Mel spectrogram(s)

    options: DecodingOptions
        A dataclass that contains all necessary options for decoding 30-second segments

    Returns
    -------
    result: Union[DecodingResult, List[DecodingResult]]
        The result(s) of decoding contained in `DecodingResult` dataclass instance(s)
    """
    ...

