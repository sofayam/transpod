"""
This type stub file was generated by pyright.
"""

import sys

if sys.version_info >= (3, 0):
    basestring = str
FRAME_WIDTHS = ...
ARRAY_TYPES = ...
ARRAY_RANGES = ...
def get_frame_width(bit_depth): # -> int:
    ...

def get_array_type(bit_depth, signed=...): # -> str:
    ...

def get_min_max_value(bit_depth): # -> tuple[int, int]:
    ...

def db_to_float(db, using_amplitude=...): # -> float:
    """
    Converts the input db to a float, which represents the equivalent
    ratio in power.
    """
    ...

def ratio_to_db(ratio, val2=..., using_amplitude=...): # -> float:
    """
    Converts the input float to db, which represents the equivalent
    to the ratio in power represented by the multiplier passed in.
    """
    ...

def register_pydub_effect(fn, name=...): # -> Callable[..., Any]:
    """
    decorator for adding pydub effects to the AudioSegment objects.
    example use:
        @register_pydub_effect
        def normalize(audio_segment):
            ...
    or you can specify a name:
        @register_pydub_effect("normalize")
        def normalize_audio_segment(audio_segment):
            ...
    """
    ...

def make_chunks(audio_segment, chunk_length): # -> list[Any]:
    """
    Breaks an AudioSegment into chunks that are <chunk_length> milliseconds
    long.
    if chunk_length is 50 then you'll get a list of 50 millisecond long audio
    segments back (except the last one, which can be shorter)
    """
    ...

def which(program): # -> str | None:
    """
    Mimics behavior of UNIX which command.
    """
    ...

def get_encoder_name(): # -> Literal['avconv', 'ffmpeg']:
    """
    Return enconder default application for system, either avconv or ffmpeg
    """
    ...

def get_player_name(): # -> Literal['avplay', 'ffplay']:
    """
    Return enconder default application for system, either avconv or ffmpeg
    """
    ...

def get_prober_name(): # -> Literal['avprobe', 'ffprobe']:
    """
    Return probe application, either avconv or ffmpeg
    """
    ...

def fsdecode(filename): # -> str:
    """Wrapper for os.fsdecode which was introduced in python 3.2 ."""
    ...

def get_extra_info(stderr): # -> dict[Any, Any]:
    """
    avprobe sometimes gives more information on stderr than
    on the json output. The information has to be extracted
    from stderr of the format of:
    '    Stream #0:0: Audio: flac, 88200 Hz, stereo, s32 (24 bit)'
    or (macOS version):
    '    Stream #0:0: Audio: vorbis'
    '      44100 Hz, stereo, fltp, 320 kb/s'

    :type stderr: str
    :rtype: list of dict
    """
    ...

def mediainfo_json(filepath, read_ahead_limit=...): # -> Any:
    """Return json dictionary with media info(codec, duration, size, bitrate...) from filepath
    """
    ...

def mediainfo(filepath): # -> dict[Any, Any]:
    """Return dictionary with media info(codec, duration, size, bitrate...) from filepath
    """
    ...

def cache_codecs(function): # -> _Wrapped[Callable[..., Any], Any, Callable[[], Any], Any]:
    ...

@cache_codecs
def get_supported_codecs(): # -> list[Any] | tuple[set[Any], set[Any]]:
    ...

def get_supported_decoders(): # -> set[Any]:
    ...

def get_supported_encoders(): # -> set[Any]:
    ...

def stereo_to_ms(audio_segment):
    '''
	Left-Right -> Mid-Side
	'''
    ...

def ms_to_stereo(audio_segment):
    '''
	Mid-Side -> Left-Right
	'''
    ...

