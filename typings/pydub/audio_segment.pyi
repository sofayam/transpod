"""
This type stub file was generated by pyright.
"""

import sys
from StringIO import StringIO

if sys.version_info >= (3, 0):
    basestring = str
    xrange = range
    StringIO = ...
class ClassPropertyDescriptor:
    def __init__(self, fget, fset=...) -> None:
        ...
    
    def __get__(self, obj, klass=...):
        ...
    
    def __set__(self, obj, value):
        ...
    
    def setter(self, func): # -> Self:
        ...
    


def classproperty(func): # -> ClassPropertyDescriptor:
    ...

AUDIO_FILE_EXT_ALIASES = ...
WavSubChunk = ...
WavData = ...
def extract_wav_headers(data): # -> list[Any]:
    ...

def read_wav_audio(data, headers=...): # -> WavData:
    ...

def fix_wav_headers(data): # -> None:
    ...

class AudioSegment:
    """
    AudioSegments are *immutable* objects representing segments of audio
    that can be manipulated using python code.

    AudioSegments are slicable using milliseconds.
    for example:
        a = AudioSegment.from_mp3(mp3file)
        first_second = a[:1000] # get the first second of an mp3
        slice = a[5000:10000] # get a slice from 5 to 10 seconds of an mp3
    """
    converter = ...
    @classproperty
    def ffmpeg(cls): # -> str:
        ...
    
    @ffmpeg.setter
    def ffmpeg(cls, val): # -> None:
        ...
    
    DEFAULT_CODECS = ...
    def __init__(self, data=..., *args, **kwargs) -> None:
        ...
    
    @property
    def raw_data(self): # -> bytes | None:
        """
        public access to the raw audio data as a bytestring
        """
        ...
    
    def get_array_of_samples(self, array_type_override=...): # -> array[Any]:
        """
        returns the raw_data as an array of samples
        """
        ...
    
    @property
    def array_type(self): # -> str:
        ...
    
    def __len__(self):
        """
        returns the length of this audio segment in milliseconds
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __iter__(self): # -> Generator[Generator[Any, None, None] | Self, None, None]:
        ...
    
    def __getitem__(self, millisecond): # -> Generator[Any, None, None] | Self:
        ...
    
    def get_sample_slice(self, start_sample=..., end_sample=...): # -> Self:
        """
        Get a section of the audio segment by sample index.

        NOTE: Negative indices do *not* address samples backword
        from the end of the audio segment like a python list.
        This is intentional.
        """
        ...
    
    def __add__(self, arg): # -> Self:
        ...
    
    def __radd__(self, rarg): # -> Self:
        """
        Permit use of sum() builtin with an iterable of AudioSegments
        """
        ...
    
    def __sub__(self, arg): # -> Self:
        ...
    
    def __mul__(self, arg): # -> Self:
        """
        If the argument is an AudioSegment, overlay the multiplied audio
        segment.

        If it's a number, just use the string multiply operation to repeat the
        audio.

        The following would return an AudioSegment that contains the
        audio of audio_seg eight times

        `audio_seg * 8`
        """
        ...
    
    @classmethod
    def empty(cls): # -> Self:
        ...
    
    @classmethod
    def silent(cls, duration=..., frame_rate=...): # -> Self:
        """
        Generate a silent audio segment.
        duration specified in milliseconds (default duration: 1000ms, default frame_rate: 11025).
        """
        ...
    
    @classmethod
    def from_mono_audiosegments(cls, *mono_segments): # -> Self:
        ...
    
    @classmethod
    def from_file_using_temporary_files(cls, file, format=..., codec=..., parameters=..., start_second=..., duration=..., **kwargs):
        ...
    
    @classmethod
    def from_file(cls, file, format=..., codec=..., parameters=..., start_second=..., duration=..., **kwargs):
        ...
    
    @classmethod
    def from_mp3(cls, file, parameters=...):
        ...
    
    @classmethod
    def from_flv(cls, file, parameters=...):
        ...
    
    @classmethod
    def from_ogg(cls, file, parameters=...):
        ...
    
    @classmethod
    def from_wav(cls, file, parameters=...):
        ...
    
    @classmethod
    def from_raw(cls, file, **kwargs):
        ...
    
    def export(self, out_f=..., format=..., codec=..., bitrate=..., parameters=..., tags=..., id3v2_version=..., cover=...): # -> IO[Any] | PathLike[Any]:
        """
        Export an AudioSegment to a file with given options

        out_f (string):
            Path to destination audio file. Also accepts os.PathLike objects on
            python >= 3.6

        format (string)
            Format for destination audio file.
            ('mp3', 'wav', 'raw', 'ogg' or other ffmpeg/avconv supported files)

        codec (string)
            Codec used to encode the destination file.

        bitrate (string)
            Bitrate used when encoding destination file. (64, 92, 128, 256, 312k...)
            Each codec accepts different bitrate arguments so take a look at the
            ffmpeg documentation for details (bitrate usually shown as -b, -ba or
            -a:b).

        parameters (list of strings)
            Aditional ffmpeg/avconv parameters

        tags (dict)
            Set metadata information to destination files
            usually used as tags. ({title='Song Title', artist='Song Artist'})

        id3v2_version (string)
            Set ID3v2 version for tags. (default: '4')

        cover (file)
            Set cover for audio file from image file. (png or jpg)
        """
        ...
    
    def get_frame(self, index): # -> bytes:
        ...
    
    def frame_count(self, ms=...): # -> float:
        """
        returns the number of frames for the given number of milliseconds, or
            if not specified, the number of frames in the whole AudioSegment
        """
        ...
    
    def set_sample_width(self, sample_width): # -> Self:
        ...
    
    def set_frame_rate(self, frame_rate): # -> Self:
        ...
    
    def set_channels(self, channels): # -> Self | AudioSegment:
        ...
    
    def split_to_mono(self): # -> list[Self] | list[Any]:
        ...
    
    @property
    def rms(self): # -> int:
        ...
    
    @property
    def dBFS(self): # -> float:
        ...
    
    @property
    def max(self): # -> int:
        ...
    
    @property
    def max_possible_amplitude(self): # -> Any:
        ...
    
    @property
    def max_dBFS(self): # -> float:
        ...
    
    @property
    def duration_seconds(self): # -> float:
        ...
    
    def get_dc_offset(self, channel=...): # -> Any:
        """
        Returns a value between -1.0 and 1.0 representing the DC offset of a
        channel (1 for left, 2 for right).
        """
        ...
    
    def remove_dc_offset(self, channel=..., offset=...): # -> Self:
        """
        Removes DC offset of given channel. Calculates offset if it's not given.
        Offset values must be in range -1.0 to 1.0. If channel is None, removes
        DC offset from all available channels.
        """
        ...
    
    def apply_gain(self, volume_change): # -> Self:
        ...
    
    def overlay(self, seg, position=..., loop=..., times=..., gain_during_overlay=...): # -> Self:
        """
        Overlay the provided segment on to this segment starting at the
        specificed position and using the specfied looping beahvior.

        seg (AudioSegment):
            The audio segment to overlay on to this one.

        position (optional int):
            The position to start overlaying the provided segment in to this
            one.

        loop (optional bool):
            Loop seg as many times as necessary to match this segment's length.
            Overrides loops param.

        times (optional int):
            Loop seg the specified number of times or until it matches this
            segment's length. 1 means once, 2 means twice, ... 0 would make the
            call a no-op
        gain_during_overlay (optional int):
            Changes this segment's volume by the specified amount during the
            duration of time that seg is overlaid on top of it. When negative,
            this has the effect of 'ducking' the audio under the overlay.
        """
        ...
    
    def append(self, seg, crossfade=...):
        ...
    
    def fade(self, to_gain=..., from_gain=..., start=..., end=..., duration=...): # -> Self:
        """
        Fade the volume of this audio segment.

        to_gain (float):
            resulting volume_change in db

        start (int):
            default = beginning of the segment
            when in this segment to start fading in milliseconds

        end (int):
            default = end of the segment
            when in this segment to start fading in milliseconds

        duration (int):
            default = until the end of the audio segment
            the duration of the fade
        """
        ...
    
    def fade_out(self, duration): # -> Self:
        ...
    
    def fade_in(self, duration): # -> Self:
        ...
    
    def reverse(self): # -> Self:
        ...
    


